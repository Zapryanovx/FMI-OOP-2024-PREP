## Задача първа

Да се реализира полиморфна йерархия за работа колекции от цели числа. Всяка от колекциите трябва да съдържа:
* `add`      - Добавя елемент към колекцията.
* `remove`   - Премахва елемент от колекцията.
* `count`    - Връжа колко елемента с тази стойност имаме.
* `contains` - Връща дали елемента се съдържа в колекцията.

Ща раелизираме следните колекции:
* NormalCollection - Това е стандартната динамична колекция.
  * add      - O(1)
  * remove   - O(n) (remove e O(1) ако премахваме по индекс)
  * count    - O(n)
  * contains - O(n)
   
* SortedCollection - Колекция в която елементите са сортирани
  * add      - O(n)
  * remove   - O(n)
  * count    - O(log(n))
  * contains - O(log(n)) - двоично търсене.

* IntervalCollection - Колекция, която допуска числа само от определен интервал (примерно [5, 49])
  * add      - O(1)
  * remove   - O(1)
  * count    - O(1)
  * contains - O(1)

* UnionSupersetCollection
  * Представлява надмножество на обединението на две колекции.
* IntersectionSupersetCollection
  * Представлява надмножество на сечението на две колекции
    
Напишете функция, която приема произвола колекция от горните и измерва нейния performance за подадени входни данни.
Да се направи сравнение между различните колекции.

## Задача втора
Да се реализира полиморфна йерархия от обекти, които знаят как да се сериализират и десиализират масиви.
Всеки обект поддържа:
* int* read(size_t&);
* void write(int*, size_t);
Всеки обект пази път към файла, в който пише или чете.

Да се реализират следните наследници:
* BinaryFileSerializer - Сериализира и десериализира масиви от двоичен файл.
* CSVFileSerializer - Сериализира и десериализира масиви от .csv файл.
* ArrayFileSerializer - Сериализира и десериализира масиви от .arr файл. Масивите в .arr файловете спазват следния синтаксис:
``` [1, 2, 3, 4] ```

От потребителя се подават два файла. Да се десериализира информацията от първия и да се запише в сортиран вид във втория.